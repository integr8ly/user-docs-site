<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Resolving Conflicts on the client :: Integreatly Docs Site</title>
    <link rel="canonical" href="https://integr8ly.github.io/user-docs-site/data-sync/latest/js-client-conflict.html">
    <meta name="generator" content="Antora 2.2.0">
    <link rel="stylesheet" href="../../_/css/site.css">
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://integr8ly.github.io/user-docs-site">Integreatly Docs Site</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
          <a class="navbar-item" href="/"><img src="https://avatars1.githubusercontent.com/u/41683098?s=80&v=4"</a>        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-item" href="https://github.com/integr8ly"> </a>
          
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
                  </div>
        <div class="navbar-item">
         </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="data-sync" data-version="latest">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="index.html">Data Sync</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Data Sync</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ds-introduction.html">Introduction</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ds-getting-started.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ds-query.html">Queries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ds-mutation.html">Mutations</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ds-offline.html">Offline</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ds-realtime.html">Subscriptions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ds-auth.html">Authz</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ds-conflict.html">Conflict Resolution</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ds-files.html">File Upload</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="ds-openshift.html">Running on Integreatly</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Data Sync</span>
    <span class="version">latest</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Data Sync</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="index.html">latest</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Integreatly</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../integreatly/index.html">master</a>
        </li>
        <li class="version">
          <a href="../../integreatly/v1.7/index.html">v1.7</a>
        </li>
        <li class="version">
          <a href="../../integreatly/v1.6/index.html">v1.6</a>
        </li>
        <li class="version">
          <a href="../../integreatly/v1.5/index.html">v1.5</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Push Notifications</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../push/latest/index.html">latest</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../integreatly/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="index.html">Data Sync</a></li>
    <li><a href="js-client-conflict.html">Resolving Conflicts on the client</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a href="https://github.com/aerogear/datasync/edit/master/docs/integreatly/modules/ROOT/pages/js-client-conflict.adoc">Edit this Page</a></div>
  </div>
  <div class="content">
<article class="doc">
<h1 class="page">Resolving Conflicts on the client</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>A typical flow for resolving conflicts includes the following steps:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>A Mutation Occurs</strong> - A client tries to modify or delete an object on the server using a GraphQL mutation.</p>
</li>
<li>
<p><strong>Read the Object</strong> - The server reads the current object the client is trying to modify from the data source (usually a database).</p>
</li>
<li>
<p><strong>Conflict Detection</strong> - The server compares the current object with the data sent by the client to see if there was a conflict. If there is a conflict, the server returns a response to the client containing information outlined in <a href="#error-structure">Structure of the Conflict Error</a></p>
</li>
<li>
<p><strong>Conflict Resolution</strong> - The client attempts to resolve this conflict and makes a new request to the server in the hope that this data is no longer conflicted.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The conflict resolution implementation requires the following additions to your application:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>returnType</code> added to the context of any mutation. see: <a href="#working-with-conflicts-client">Working With Conflict Resolution on the Client</a>.</p>
</li>
<li>
<p>Additional metadata inside types (for example version field) depending on the conflict implementation you chose. see: <a href="#version-based-conflict">Version Based Conflict Detection</a>.</p>
</li>
<li>
<p>Server-side resolvers to return conflicts back to clients first. For more information, see: <a href="#conflict-resolution-{context}">Server Side Conflict Detection</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Developers can either use the default conflict resolution implementations, or implement their own conflict resolution implementations using the conflict resolution mechanism.</p>
</div>
<div class="paragraph">
<p>By default, when no changes are made on the same fields, the implementation attempts to resend the modified payload back to the server.
When changes on the server and on the client affect the same fields, one of the specified conflict resolution strategies can be used.
The default strategy applies client changes on top of the server side data.
Developers can modify strategies to suit their needs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="working-with-conflicts-client"><a class="anchor" href="#working-with-conflicts-client"></a>Implementing conflict resolution on the client</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To enable conflict resolution, the server side resolvers must be configured to perform conflict detection.
Detection can rely on different implementations and return the conflict error back to the client.
See <a href="#conflict-resolution-{context}">Server Side Conflict Detection</a> for more information.</p>
</div>
<div class="paragraph">
<div class="title">Procedure</div>
<p>Provide the mutation context with the <code>returnType</code> parameter to resolve conflicts.
This parameter defines the Object type being operated on.
You can implement this in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If using {sync-service}'s <code>offlineMutate</code> you can provide the <code>returnType</code> parameter directly as follows:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">client.offlineMutate({
  ...
  returnType: 'Task'
  ...
})</code></pre>
</div>
</div>
</li>
<li>
<p>If using Apollo&#8217;s <code>mutate</code> function, provide the <code>returnType</code> parameter as follows:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">client.mutate({
  ...
  context: {
    returnType: 'Task'
  }
  ...
})</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The client automatically resolves the conflicts based on the current strategy and notifies listeners as required.</p>
</div>
<div class="paragraph">
<p>Conflict resolution works with the recommended defaults and does not require any specific handling on the client.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For advanced use cases, the conflict implementation can be customised by supplying a custom <code>conflictProvider</code> in the application config. See <a href="#conflict-resolution-strategies">Conflict Resolution Strategies</a> below.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_about_the_default_conflict_implementation"><a class="anchor" href="#_about_the_default_conflict_implementation"></a>About the default conflict implementation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>By default, conflict resolution is configured to rely on a <code>version</code> field on each GraphQL type.
You must save a version field to the database in order to detect changes on the server.
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">type User {
  id: ID!
  version: String!
  name: String!
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The version field is controlled on the server and maps the last version that was sent from the server.
All operations on the version field happen automatically.
Make sure that the version field is always passed to the server for mutations that supports conflict resolution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">type Mutation {
  updateUser(id: ID!, version: String!): User
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="conflict-resolution-strategies"><a class="anchor" href="#conflict-resolution-strategies"></a>Implementing conflict resolution strategies</h2>
<div class="sectionbody">
<div class="paragraph">
<p>{sync-service} allows developers to define custom conflict resolution strategies. You can provide custom conflict resolution strategies to the client in the config by using the provided <code>ConflictResolutionStrategies</code> type.
By default developers do not need to pass any strategy as <code>UseClient</code> is the default.
Custom strategies can also be used to provide different resolution strategies for certain operations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let customStrategy = {
  resolve = (base, server, client, operationName) =&gt; {
    let resolvedData;
    switch (operationName) {
      case "updateUser":
        delete client.socialKey
        resolvedData = Object.assign(base, server, client)
        break
      case "updateRole":
        client.role = "none"
        resolvedData = Object.assign(base, server, client)
        break
      default:
        resolvedData = Object.assign(base, server, client)
    }
    return resolvedData
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This custom strategy object provides two distinct strategies.
The strategies are named to match the operation.
You pass the name of the object as an argument to conflictStrategy in your config object:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">let config = {
...
  conflictStrategy: customStrategy
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_listening_to_conflicts"><a class="anchor" href="#_listening_to_conflicts"></a>Listening to conflicts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>{sync-service} allows developers to receive information about the data conflict.</p>
</div>
<div class="paragraph">
<p>When a conflict occurs, {sync-service} attempts to perform a field level resolution of data - it checks all fields of its type to see if both the client or server has changed the same field.
The client can be notified in one of two scenarios.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If both client and server have changed any of the same fields, the <code>conflictOccurred</code> method of the <code>ConflictListener</code> is triggered.</p>
</li>
<li>
<p>If the client and server have not changed any of the same fields, and the data can be easily merged, the <code>mergeOccurred</code> method of your <code>ConflictListener</code> is triggered.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Developers can supply their own <code>conflictListener</code> implementation, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">class ConflictLogger implements ConflictListener {
  conflictOccurred(operationName, resolvedData, server, client) {
    console.log("Conflict occurred with the following:")
    console.log(`data: ${JSON.stringify(resolvedData)}, server: ${JSON.stringify(server)}, client: ${JSON.stringify(client)}, operation:  ${JSON.stringify(operationName)}`);
  }
  mergeOccurred(operationName, resolvedData, server, client) {
    console.log("Merge occurred with the following:")
    console.log(`data: ${JSON.stringify(resolvedData)}, server: ${JSON.stringify(server)}, client: ${JSON.stringify(client)}, operation:  ${JSON.stringify(operationName)}`);
  }
}

let config = {
...
  conflictListener: new ConflictLogger()
...
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_handling_pre_conflict_errors"><a class="anchor" href="#_handling_pre_conflict_errors"></a>Handling pre-conflict errors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>{sync-service} provides a mechanism for developers to check for a 'pre-conflict' before a mutation occurs.
It checks whether or not the data being sent conflicts locally.
This happens when a mutation (or the act of creating a mutation) is initiated.</p>
</div>
<div class="paragraph">
<p>For example, consider a user performing the following actions:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>opens a form</p>
</li>
<li>
<p>begins working on the pre-populated data on this form</p>
</li>
<li>
<p>the client receives new data from the server from subscriptions</p>
</li>
<li>
<p>the client is now conflicted but the user is unaware</p>
</li>
<li>
<p>when the user presses <strong>Submit</strong> {sync-service} notices that their data is conflicted and provides the developer with the information to warn the user</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>To use this feature, and therefore potentially save unecessary round-trips to the server with data which is definitely conflicted, developers can make use of the error returned by {sync-service}.</p>
</div>
<div class="paragraph">
<p>An example of how developers can use this error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-javascript hljs" data-lang="javascript">return client.offlineMutate({
  ...
}).then(result =&gt; {
  // handle the result
}).catch(error =&gt; {
  if (error.networkError &amp;&amp; error.networkError.localConflict) {
    // handle pre-conflict here by potentially
    // providing an alert with a chance to update data before pressing send again
  }
})</code></pre>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This site was built using <a href="http://docs.antora.org">Antora</a> .</p>
</footer>
<script src="../../_/js/site.js"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
